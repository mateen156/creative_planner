import { __decorate, __metadata, __param } from "tslib";
import { Injectable, NgZone, Optional } from '@angular/core';
import { PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { LoadingBarState } from './loading-bar.state';
import { Subject, combineLatest, Observable } from 'rxjs';
import { switchMap, map, startWith } from 'rxjs/operators';
import { LOADING_BAR_CONFIG } from './loading-bar.config';
import * as i0 from "@angular/core";
import * as i1 from "./loading-bar.config";
import * as ɵngcc0 from '@angular/core';
let LoadingBarService = class LoadingBarService {
    constructor(platformId, config = {}, zone) {
        this.platformId = platformId;
        this.config = config;
        this.zone = zone;
        this.refs = {};
        this.streams$ = new Subject();
        this.value$ = this.streams$.asObservable().pipe(startWith(null), switchMap(() => combineLatest(...Object.keys(this.refs).map((s) => this.refs[s].value$))), runInZone(this.zone), map((v) => Math.max(0, ...v)));
    }
    /** @deprecated use `value$` instead. */
    get progress$() {
        return this.value$;
    }
    /** @deprecated use `useRef` instead. */
    start(initialValue = 2) {
        this.useRef().start(initialValue);
    }
    /** @deprecated use `useRef` instead. */
    set(value) {
        this.useRef().set(value);
    }
    /** @deprecated use `useRef` instead. */
    increment(value) {
        this.useRef().increment(value);
    }
    /** @deprecated use `useRef` instead. */
    complete() {
        this.useRef().complete();
    }
    /** @deprecated use `useRef` instead. */
    stop() {
        this.useRef().stop();
    }
    useRef(id = 'default') {
        if (!this.refs[id]) {
            this.refs[id] = new LoadingBarState(this.config);
            this.streams$.next();
            if (!isPlatformBrowser(this.platformId)) {
                this.refs[id].disable();
            }
        }
        return this.refs[id];
    }
};
LoadingBarService.ɵfac = function LoadingBarService_Factory(t) { return new (t || LoadingBarService)(ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(LOADING_BAR_CONFIG, 8), ɵngcc0.ɵɵinject(ɵngcc0.NgZone, 8)); };
LoadingBarService.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOADING_BAR_CONFIG,] }] },
    { type: NgZone, decorators: [{ type: Optional }] }
];
LoadingBarService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LoadingBarService_Factory() { return new LoadingBarService(i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i1.LOADING_BAR_CONFIG, 8), i0.ɵɵinject(i0.NgZone, 8)); }, token: LoadingBarService, providedIn: "root" });
LoadingBarService = __decorate([ __param(0, Inject(PLATFORM_ID)),
    __param(1, Optional()), __param(1, Inject(LOADING_BAR_CONFIG)),
    __param(2, Optional()),
    __metadata("design:paramtypes", [Object, Object, NgZone])
], LoadingBarService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoadingBarService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [LOADING_BAR_CONFIG]
            }] }, { type: ɵngcc0.NgZone, decorators: [{
                type: Optional
            }] }]; }, null); })();
export { LoadingBarService };
// https://stackoverflow.com/a/57452361/1406096
export function runInZone(zone) {
    if (!zone) {
        return (source) => source;
    }
    return (source) => new Observable((observer) => source.subscribe((value) => zone.run(() => observer.next(value)), (e) => zone.run(() => observer.error(e)), () => zone.run(() => observer.complete())));
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGluZy1iYXIuc2VydmljZS5qcyIsInNvdXJjZXMiOlsibmc6L0BuZ3gtbG9hZGluZy1iYXIvY29yZS9sb2FkaW5nLWJhci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBb0IsTUFBTSxNQUFNLENBQUM7QUFDNUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0QsT0FBTyxFQUFFLGtCQUFrQixFQUFvQixNQUFNLHNCQUFzQixDQUFDO0FBQzVFO0FBRUE7O0FBQUEsSUFBYSxpQkFBaUIsR0FBOUIsTUFBYSxpQkFBaUI7QUFDOUIsSUFjRSxZQUMrQixVQUFrQixFQUNDLFNBQTJCLEVBQUUsRUFDekQsSUFBYTtBQUNuQyxRQUgrQixlQUFVLEdBQVYsVUFBVSxDQUFRO0FBQUMsUUFDQSxXQUFNLEdBQU4sTUFBTSxDQUF1QjtBQUFDLFFBQzFELFNBQUksR0FBSixJQUFJLENBQVM7QUFBQyxRQWpCNUIsU0FBSSxHQUFzQyxFQUFFLENBQUM7QUFDdkQsUUFBVSxhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztBQUN6QyxRQUFXLFdBQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDLElBQUksQ0FDakQsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUNmLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsR0FBRyxN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O0FBNEQ5QiwrQ0FBK0M7QUFDL0MsTUFBTSxVQUFVLFNBQVMsQ0FBSSxJQUFZO0FBQUksSUFDM0MsSUFBSSxDQUFDLElBQUksRUFBRTtBQUNiLFFBQUksT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDO0FBQzlCLEtBQUc7QUFDSCxJQUNFLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUNoQixJQUFJLFVBQVUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQzFCLE1BQU0sQ0FBQyxTQUFTLENBQ2QsQ0FBQyxLQUFRLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUNsRCxDQUFDLENBQU0sRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQzdDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQzFDLENBQ0YsQ0FBQztBQUNOLENBQUM7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFBMQVRGT1JNX0lELCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IExvYWRpbmdCYXJTdGF0ZSB9IGZyb20gJy4vbG9hZGluZy1iYXIuc3RhdGUnO1xuaW1wb3J0IHsgU3ViamVjdCwgY29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZSwgT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCBtYXAsIHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IExPQURJTkdfQkFSX0NPTkZJRywgTG9hZGluZ0JhckNvbmZpZyB9IGZyb20gJy4vbG9hZGluZy1iYXIuY29uZmlnJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBMb2FkaW5nQmFyU2VydmljZSB7XG4gIHByaXZhdGUgcmVmczogeyBbaWQ6IHN0cmluZ106IExvYWRpbmdCYXJTdGF0ZSB9ID0ge307XG4gIHByaXZhdGUgc3RyZWFtcyQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICByZWFkb25seSB2YWx1ZSQgPSB0aGlzLnN0cmVhbXMkLmFzT2JzZXJ2YWJsZSgpLnBpcGUoXG4gICAgc3RhcnRXaXRoKG51bGwpLFxuICAgIHN3aXRjaE1hcCgoKSA9PiBjb21iaW5lTGF0ZXN0KC4uLk9iamVjdC5rZXlzKHRoaXMucmVmcykubWFwKChzKSA9PiB0aGlzLnJlZnNbc10udmFsdWUkKSkpLFxuICAgIHJ1bkluWm9uZSh0aGlzLnpvbmUpLFxuICAgIG1hcCgodikgPT4gTWF0aC5tYXgoMCwgLi4udikpLFxuICApO1xuXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHZhbHVlJGAgaW5zdGVhZC4gKi9cbiAgZ2V0IHByb2dyZXNzJCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZSQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KExPQURJTkdfQkFSX0NPTkZJRykgcHJpdmF0ZSBjb25maWc6IExvYWRpbmdCYXJDb25maWcgPSB7fSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIHpvbmU/OiBOZ1pvbmUsXG4gICkge31cblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGB1c2VSZWZgIGluc3RlYWQuICovXG4gIHN0YXJ0KGluaXRpYWxWYWx1ZSA9IDIpIHtcbiAgICB0aGlzLnVzZVJlZigpLnN0YXJ0KGluaXRpYWxWYWx1ZSk7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGB1c2VSZWZgIGluc3RlYWQuICovXG4gIHNldCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy51c2VSZWYoKS5zZXQodmFsdWUpO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdXNlUmVmYCBpbnN0ZWFkLiAqL1xuICBpbmNyZW1lbnQodmFsdWU/OiBudW1iZXIpIHtcbiAgICB0aGlzLnVzZVJlZigpLmluY3JlbWVudCh2YWx1ZSk7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGB1c2VSZWZgIGluc3RlYWQuICovXG4gIGNvbXBsZXRlKCkge1xuICAgIHRoaXMudXNlUmVmKCkuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHVzZVJlZmAgaW5zdGVhZC4gKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnVzZVJlZigpLnN0b3AoKTtcbiAgfVxuXG4gIHVzZVJlZihpZDogc3RyaW5nID0gJ2RlZmF1bHQnKTogTG9hZGluZ0JhclN0YXRlIHtcbiAgICBpZiAoIXRoaXMucmVmc1tpZF0pIHtcbiAgICAgIHRoaXMucmVmc1tpZF0gPSBuZXcgTG9hZGluZ0JhclN0YXRlKHRoaXMuY29uZmlnKTtcbiAgICAgIHRoaXMuc3RyZWFtcyQubmV4dCgpO1xuXG4gICAgICBpZiAoIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgICAgdGhpcy5yZWZzW2lkXS5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVmc1tpZF07XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU3NDUyMzYxLzE0MDYwOTZcbmV4cG9ydCBmdW5jdGlvbiBydW5JblpvbmU8VD4oem9uZTogTmdab25lKTogT3BlcmF0b3JGdW5jdGlvbjxULCBUPiB7XG4gIGlmICghem9uZSkge1xuICAgIHJldHVybiAoc291cmNlKSA9PiBzb3VyY2U7XG4gIH1cblxuICByZXR1cm4gKHNvdXJjZSkgPT5cbiAgICBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+XG4gICAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICAodmFsdWU6IFQpID0+IHpvbmUucnVuKCgpID0+IG9ic2VydmVyLm5leHQodmFsdWUpKSxcbiAgICAgICAgKGU6IGFueSkgPT4gem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIuZXJyb3IoZSkpLFxuICAgICAgICAoKSA9PiB6b25lLnJ1bigoKSA9PiBvYnNlcnZlci5jb21wbGV0ZSgpKSxcbiAgICAgICksXG4gICAgKTtcbn1cbiJdfQ==