import { __decorate, __metadata } from "tslib";
import { LoadingBarService } from '@ngx-loading-bar/core';
import { Injectable } from '@angular/core';
import { finalize, tap } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@ngx-loading-bar/core';
var LoadingBarInterceptor = /** @class */ (function () {
    function LoadingBarInterceptor(loader) {
        this.loader = loader;
    }
    LoadingBarInterceptor.prototype.intercept = function (req, next) {
        // https://github.com/angular/angular/issues/18155
        if (req.headers.has('ignoreLoadingBar')) {
            return next.handle(req.clone({ headers: req.headers.delete('ignoreLoadingBar') }));
        }
        var started = false;
        var ref = this.loader.useRef('http');
        return next.handle(req).pipe(tap(function () {
            if (!started) {
                ref.start();
                started = true;
            }
        }), finalize(function () { return started && ref.complete(); }));
    };
    LoadingBarInterceptor.ctorParameters = function () { return [
        { type: LoadingBarService }
    ]; };
    LoadingBarInterceptor = __decorate([ __metadata("design:paramtypes", [LoadingBarService])
    ], LoadingBarInterceptor);
LoadingBarInterceptor.ɵfac = function LoadingBarInterceptor_Factory(t) { return new (t || LoadingBarInterceptor)(ɵngcc0.ɵɵinject(ɵngcc1.LoadingBarService)); };
LoadingBarInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LoadingBarInterceptor, factory: function (t) { return LoadingBarInterceptor.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoadingBarInterceptor, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.LoadingBarService }]; }, null); })();
    return LoadingBarInterceptor;
}());
export { LoadingBarInterceptor };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGluZy1iYXIuaW50ZXJjZXB0b3IuanMiLCJzb3VyY2VzIjpbIm5nOi9Abmd4LWxvYWRpbmctYmFyL2h0dHAtY2xpZW50L2xvYWRpbmctYmFyLmludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLE9BQU8sRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQUcvQztBQUF5RCxJQUN2RCwrQkFBb0IsTUFBeUI7QUFBSSxRQUE3QixXQUFNLEdBQU4sTUFBTSxDQUFtQjtBQUFDLElBQUUsQ0FBQztBQUNuRCxJQUNFLHlDQUFTLEdBQVQsVUFBVSxHQUFxQixFQUFFLElBQWlCO0FBQUksUUFDcEQsa0RBQWtEO0FBQ3RELFFBQUksSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO0FBQzdDLFlBQU0sT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUN6RixTQUFLO0FBQ0wsUUFDSSxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDeEIsUUFBSSxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMzQyxRQUFJLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQzFCLEdBQUcsQ0FBQztBQUNKLFlBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRTtBQUN0QixnQkFBVSxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDdEIsZ0JBQVUsT0FBTyxHQUFHLElBQUksQ0FBQztBQUN6QixhQUFTO0FBQ1QsUUFBTSxDQUFDLENBQUMsRUFDRixRQUFRLENBQUMsY0FBTSxPQUFBLE9BQU8sSUFBSSxHQUFHLENBQUMsUUFBUSxFQUFFLEVBQXpCLENBQXlCLENBQUMsQ0FDMUMsQ0FBQztBQUNOLElBQUUsQ0FBQztBQUNGO0FBQ2dFLGdCQXJCbkMsaUJBQWlCO0FBQUc7QUFFM0MsSUFITSxxQkFBcUIsd0JBRGpDLFVBQVUsRUFBRSxyQkFDTCxrQ0FDc0IsaUJBQWlCO0FBQUcsT0FEckMscUJBQXFCLENBcUJqQzs7Ozs7a0ZBQ0Q7QUFBQyxJQURELDRCQUFDO0FBQ0EsQ0FEQSxBQXJCRCxJQXFCQztBQUNELFNBdEJhLHFCQUFxQjtBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGluZ0JhclNlcnZpY2UgfSBmcm9tICdAbmd4LWxvYWRpbmctYmFyL2NvcmUnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSHR0cEV2ZW50LCBIdHRwSW50ZXJjZXB0b3IsIEh0dHBIYW5kbGVyLCBIdHRwUmVxdWVzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbmFsaXplLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBMb2FkaW5nQmFySW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGxvYWRlcjogTG9hZGluZ0JhclNlcnZpY2UpIHt9XG5cbiAgaW50ZXJjZXB0KHJlcTogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTgxNTVcbiAgICBpZiAocmVxLmhlYWRlcnMuaGFzKCdpZ25vcmVMb2FkaW5nQmFyJykpIHtcbiAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEuY2xvbmUoeyBoZWFkZXJzOiByZXEuaGVhZGVycy5kZWxldGUoJ2lnbm9yZUxvYWRpbmdCYXInKSB9KSk7XG4gICAgfVxuXG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCByZWYgPSB0aGlzLmxvYWRlci51c2VSZWYoJ2h0dHAnKTtcbiAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKS5waXBlKFxuICAgICAgdGFwKCgpID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkKSB7XG4gICAgICAgICAgcmVmLnN0YXJ0KCk7XG4gICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgZmluYWxpemUoKCkgPT4gc3RhcnRlZCAmJiByZWYuY29tcGxldGUoKSksXG4gICAgKTtcbiAgfVxufVxuIl19